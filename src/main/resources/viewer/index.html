<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #error-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            max-width: 80%;
        }
    </style>
</head>

<body>
    <div id="error-container"></div>
    <script type="importmap">
    {
        "imports": {
            "three": "./libs/three/three.module.js",
            "three/addons/": "./libs/three/addons/",
            "lil-gui": "./libs/lil-gui/lil-gui.esm.js"
        }
    }
</script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        window.addEventListener('error', (event) => {
            const errorContainer = document.getElementById('error-container');
            let message = 'An unexpected error occurred: ' + event.message;
            if (event.error && event.error.stack) {
                message += '\n' + event.error.stack;
            }
            errorContainer.style.whiteSpace = 'pre-wrap';
            errorContainer.innerText = message;
            errorContainer.style.display = 'block';
            console.error('Unhandled error:', event.error);
        });

        let scene, camera, renderer, controls, gui;
        let modelDefaultCameraZ;
        let cameraParams;
        let mixer, clock;
        let ambientLight, directionalLight;
        let targetZoom;
        let isAnimatingZoom = false;
        let axesHelper, gridHelper;
        let displayParams = {
            showAxes: false,
            showGrid: true,
            wireframe: false,
            shadows: true
        };
        let groundPlane;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            modelDefaultCameraZ = controls.getDistance();
            targetZoom = modelDefaultCameraZ;

            ambientLight = new THREE.HemisphereLight(0xcccccc, 0x444444, 2);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(-5, 10, -7.5);
            scene.add(directionalLight2);

            axesHelper = new THREE.AxesHelper(1);
            axesHelper.visible = displayParams.showAxes;
            scene.add(axesHelper);

            gridHelper = new THREE.GridHelper(10, 10);
            gridHelper.visible = displayParams.showGrid;
            scene.add(gridHelper);

            const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.5 });
            groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 10),
                groundMaterial
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            groundPlane.visible = displayParams.shadows;
            scene.add(groundPlane);

            setupGui();

            window.addEventListener('resize', onWindowResize, false);

            window.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'h') {
                    gui.open(gui._closed);
                }
                if (event.key.toLowerCase() === 'r') {
                    if (cameraParams && cameraParams.reset) {
                        cameraParams.reset();
                    }
                }
            });

            animate();
        }

        function setupGui() {
            if (gui) {
                gui.destroy();
            }
            gui = new GUI();
            gui.title('Configurations')

            const displayFolder = gui.addFolder('Display');
            displayFolder.add(displayParams, 'showAxes').name('Show Axes').onChange((value) => {
                axesHelper.visible = value;
            });
            displayFolder.add(displayParams, 'showGrid').name('Show Grid').onChange((value) => {
                gridHelper.visible = value;
            });
            displayFolder.add(displayParams, 'wireframe').name('Wireframe').onChange((value) => {
                if (currentModel) {
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.material) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            materials.forEach(m => {
                                if (m) m.wireframe = value;
                            });
                        }
                    });
                }
            });
            displayFolder.add(displayParams, 'shadows').name('Shadows').onChange((value) => {
                displayParams.shadows = value;
                directionalLight.castShadow = value;
                groundPlane.visible = value;
                if (currentModel) {
                    currentModel.traverse(node => {
                        if (node.isMesh) {
                            node.castShadow = value;
                        }
                    });
                }
            });
            displayFolder.open();

            const params = {
                backgroundColor: '#' + scene.background.getHexString(),
                ambientSkyColor: '#' + ambientLight.color.getHexString(),
                ambientGroundColor: '#' + ambientLight.groundColor.getHexString(),
                directionalColor: '#' + directionalLight.color.getHexString(),
            };

            const environmentFolder = gui.addFolder('Environment');
            environmentFolder.addColor(params, 'backgroundColor').name('Background').onChange((value) => {
                scene.background.set(value);
            });

            const ambientFolder = environmentFolder.addFolder('Hemisphere Light');
            ambientFolder.add(ambientLight, 'intensity', 0, 20).name('Intensity');
            ambientFolder.addColor(params, 'ambientSkyColor').name('Sky Color').onChange((value) => {
                ambientLight.color.set(value);
            });
            ambientFolder.addColor(params, 'ambientGroundColor').name('Ground Color').onChange((value) => {
                ambientLight.groundColor.set(value);
            });

            ambientFolder.add(ambientLight.position, 'x', -20, 20).name('Position X');
            ambientFolder.add(ambientLight.position, 'y', -20, 20).name('Position Y');
            ambientFolder.add(ambientLight.position, 'z', -20, 20).name('Position Z');
            ambientFolder.close();

            const dirLightFolder = environmentFolder.addFolder('Directional Light');
            dirLightFolder.add(directionalLight, 'intensity', 0, 20).name('Intensity');
            dirLightFolder.addColor(params, 'directionalColor').name('Color').onChange((value) => {
                directionalLight.color.set(value);
            });
            dirLightFolder.add(directionalLight.position, 'x', -20, 20).name('Position X');
            dirLightFolder.add(directionalLight.position, 'y', -20, 20).name('Position Y');
            dirLightFolder.add(directionalLight.position, 'z', -20, 20).name('Position Z');
            dirLightFolder.close();

            gui.close();

            cameraParams = {
                reset: () => {
                    isAnimatingZoom = true;
                    targetZoom = modelDefaultCameraZ;
                }
            };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) {
                mixer.update(clock.getDelta());
            }

            if (isAnimatingZoom) {
                const currentDistance = controls.getDistance();
                if (Math.abs(currentDistance - targetZoom) > 0.01) {
                    const newDistance = THREE.MathUtils.lerp(currentDistance, targetZoom, 0.1);
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    if (direction.lengthSq() > 0) {
                        camera.position.copy(controls.target).addScaledVector(direction, newDistance);
                    }
                } else {
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    if (direction.lengthSq() > 0) {
                        camera.position.copy(controls.target).addScaledVector(direction, targetZoom);
                    }
                    isAnimatingZoom = false;
                }
            } else {
                if (controls.enabled) {
                    targetZoom = controls.getDistance();
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        let currentModel;

        async function loadGltf(path) {
            const loader = new GLTFLoader();
            try {
                const gltf = await loader.loadAsync(path);

                if (currentModel) {
                    scene.remove(currentModel);
                }
                if (mixer) {
                    mixer.stopAllAction();
                    mixer = null;
                    clock = null;
                }

                setupGui();

                const modelNode = gltf.scene;
                currentModel = new THREE.Group();
                currentModel.add(modelNode);
                scene.add(currentModel);

                const box = new THREE.Box3().setFromObject(modelNode);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                modelNode.position.sub(center);
                currentModel.position.y = size.y / 2;

                currentModel.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = displayParams.shadows;
                        node.receiveShadow = true;

                        if (node.material) {
                            const materials = Array.isArray(node.material) ? node.material : [node.material];
                            materials.forEach(material => {
                                if (material) material.wireframe = displayParams.wireframe;
                            });
                        }
                    }
                });
                const animations = gltf.animations;

                if (animations && animations.length) {
                    clock = new THREE.Clock();
                    mixer = new THREE.AnimationMixer(modelNode);
                    let activeAction = null;

                    const animationPanel = gui.addFolder('Animations');
                    animationPanel.close();

                    const animsByName = {};
                    animations.forEach((clip, i) => {
                        const name = clip.name || `Animation ${i + 1}`;
                        animsByName[name] = clip;
                    });

                    const animParams = {
                        clip: animations[0].name || 'Animation 1',
                        play: () => {
                            if (activeAction) {
                                activeAction.paused = !activeAction.paused;
                            } else {
                                playSelectedAnimation();
                            }
                        },
                        stop: () => {
                            if (mixer) {
                                mixer.stopAllAction();
                                activeAction = null;
                            }
                        },
                        time: 0,
                    };

                    function playSelectedAnimation() {
                        if (mixer) {
                            mixer.stopAllAction();
                        }
                        const clip = animsByName[animParams.clip];
                        if (clip) {
                            activeAction = mixer.clipAction(clip);
                            activeAction.reset().play();
                        }
                    }

                    animationPanel.add(animParams, 'clip', Object.keys(animsByName)).name('Animation').onChange(playSelectedAnimation);
                    animationPanel.add(animParams, 'play').name('Play/Pause');
                    animationPanel.add(animParams, 'stop').name('Stop');
                    animationPanel.add(mixer, 'timeScale', 0.1, 2).name('Speed');

                    playSelectedAnimation();
                }

                document.getElementById('error-container').style.display = 'none';

                const maxDim = Math.max(size.x, size.y, size.z);

                const transformFolder = gui.addFolder('Transform');
                const posRange = maxDim > 0 ? maxDim * 2 : 20;
                const updateTarget = () => controls.target.copy(currentModel.position);
                transformFolder.add(currentModel.position, 'x', -posRange, posRange, 0.01).name('Position X').onChange(updateTarget);
                transformFolder.add(currentModel.position, 'y', -posRange, posRange, 0.01).name('Position Y').onChange(updateTarget);
                transformFolder.add(currentModel.position, 'z', -posRange, posRange, 0.01).name('Position Z').onChange(updateTarget);
                transformFolder.open();

                if (maxDim > 0) {
                    // Update shadow camera to fit the model
                    const shadowCamSize = maxDim * 1.5;
                    directionalLight.shadow.camera.left = -shadowCamSize;
                    directionalLight.shadow.camera.right = shadowCamSize;
                    directionalLight.shadow.camera.top = shadowCamSize;
                    directionalLight.shadow.camera.bottom = -shadowCamSize;
                    const near = maxDim / 100;
                    const far = maxDim * 4;
                    directionalLight.shadow.camera.near = near > 0.1 ? near : 0.1;
                    directionalLight.shadow.camera.far = far > near ? far : near + 100;
                    directionalLight.shadow.camera.updateProjectionMatrix();
                    directionalLight.target.position.set(0, 0, 0);

                    axesHelper.scale.set(1, 1, 1).multiplyScalar(maxDim * 0.75);

                    scene.remove(gridHelper);
                    const gridSize = Math.ceil(maxDim) * 2;
                    const gridDivisions = 20;
                    gridHelper = new THREE.GridHelper(gridSize, gridDivisions);
                    gridHelper.visible = displayParams.showGrid;
                    scene.add(gridHelper);

                    groundPlane.geometry.dispose();
                    groundPlane.geometry = new THREE.PlaneGeometry(gridSize, gridSize);
                    groundPlane.position.y = gridHelper.position.y - 0.001;

                    // Adjust camera clipping planes to fit the model and prevent clipping
                    camera.near = Math.max(0.01, maxDim / 100);
                    camera.far = maxDim * 100;
                    camera.updateProjectionMatrix();
                }

                const fov = camera.fov * (Math.PI / 180);
                const aspect = camera.aspect;

                const distanceToFitHeight = (size.y / 2) / Math.tan(fov / 2);
                const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspect);
                const distanceToFitWidth = (size.x / 2) / Math.tan(horizontalFov / 2);

                let cameraZ = Math.max(distanceToFitHeight, distanceToFitWidth);
                cameraZ += size.z / 2; // offset for model depth
                cameraZ *= 1.2; // add 20% margin

                camera.position.set(currentModel.position.x, currentModel.position.y + size.y / 4, currentModel.position.z + cameraZ);
                controls.target.copy(currentModel.position);
                controls.update();
                modelDefaultCameraZ = controls.getDistance();
                targetZoom = modelDefaultCameraZ;
                isAnimatingZoom = false;

            } catch (error) {
                console.error(error);
                const errorContainer = document.getElementById('error-container');
                errorContainer.innerText = 'Error loading GLTF: ' + error.message;
                errorContainer.style.display = 'block';
            }
        }
        // Make functions globally available
        window.loadGltf = loadGltf;

        init();
    </script>
</body>

</html>