<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #error-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            max-width: 80%;
        }
    </style>
</head>

<body>
    <div id="error-container"></div>
    <script type="importmap">
    {
        "imports": {
            "three": "./libs/three/three.module.js",
            "three/addons/": "./libs/three/addons/",
            "lil-gui": "./libs/lil-gui/lil-gui.esm.js"
        }
    }
</script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        window.addEventListener('error', (event) => {
            const errorContainer = document.getElementById('error-container');
            let message = 'An unexpected error occurred: ' + event.message;
            if (event.error && event.error.stack) {
                message += '\n' + event.error.stack;
            }
            errorContainer.style.whiteSpace = 'pre-wrap';
            errorContainer.innerText = message;
            errorContainer.style.display = 'block';
            console.error('Unhandled error:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            const errorContainer = document.getElementById('error-container');
            let message = 'An unhandled promise rejection occurred: ';
            if (event.reason) {
                if (event.reason instanceof Error) {
                    message += event.reason.message;
                    if (event.reason.stack) {
                        message += '\n' + event.reason.stack;
                    }
                } else {
                    try {
                        message += JSON.stringify(event.reason, null, 2);
                    } catch (e) {
                        message += String(event.reason);
                    }
                }
            } else {
                message += 'No reason provided.';
            }
            errorContainer.style.whiteSpace = 'pre-wrap';
            errorContainer.innerText = message;
            errorContainer.style.display = 'block';
            console.error('Unhandled rejection:', event.reason);
        });

        let scene, camera, renderer, controls, gui;
        let modelDefaultCameraZ;
        let cameraParams;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            modelDefaultCameraZ = controls.getDistance();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            gui = new GUI();
            window.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'h') {
                    gui.domElement.style.display = gui.domElement.style.display === 'none' ? 'block' : 'none';
                }
            });

            const params = {
                backgroundColor: '#' + scene.background.getHexString(),
                ambientColor: '#' + ambientLight.color.getHexString(),
                directionalColor: '#' + directionalLight.color.getHexString(),
            };

            gui.addColor(params, 'backgroundColor').name('Background').onChange((value) => {
                scene.background.set(value);
            });

            const lightFolder = gui.addFolder('Lights');
            lightFolder.add(ambientLight, 'intensity', 0, 2).name('Ambient');
            lightFolder.addColor(params, 'ambientColor').name('Ambient Color').onChange((value) => {
                ambientLight.color.set(value);
            });

            const dirLightFolder = lightFolder.addFolder('Directional');
            dirLightFolder.add(directionalLight, 'intensity', 0, 2).name('Intensity');
            dirLightFolder.addColor(params, 'directionalColor').name('Directional Color').onChange((value) => {
                directionalLight.color.set(value);
            });
            dirLightFolder.add(directionalLight.position, 'x', -20, 20);
            dirLightFolder.add(directionalLight.position, 'y', -20, 20);
            dirLightFolder.add(directionalLight.position, 'z', -20, 20);

            const cameraFolder = gui.addFolder('Camera');
            cameraParams = {
                get zoom() {
                    return controls.getDistance();
                },
                set zoom(value) {
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    camera.position.copy(controls.target).addScaledVector(direction, value);
                    controls.update();
                },
                reset: () => {
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    camera.position.copy(controls.target).addScaledVector(direction, modelDefaultCameraZ);
                    controls.update();
                }
            };
            cameraFolder.add(cameraParams, 'zoom', 0.1, 50).name('Zoom').listen();
            cameraFolder.add(cameraParams, 'reset').name('Reset Zoom');

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        let currentModel;

        function loadGltf(path) {
            const loader = new GLTFLoader();
            loader.load(path, (gltf) => {
                if (currentModel) {
                    scene.remove(currentModel);
                }
                currentModel = gltf.scene;
                scene.add(currentModel);

                // Hide error on success
                document.getElementById('error-container').style.display = 'none';

                // Center the model
                const box = new THREE.Box3().setFromObject(currentModel);
                const center = box.getCenter(new THREE.Vector3());
                currentModel.position.sub(center); // center the model
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // zoom out a bit
                camera.position.set(0, 1, cameraZ);
                controls.target.set(0, 0, 0);
                controls.update();
                modelDefaultCameraZ = controls.getDistance();

            }, undefined, (error) => {
                console.error(error);
                const errorContainer = document.getElementById('error-container');
                errorContainer.innerText = 'Error loading GLTF: ' + error.message;
                errorContainer.style.display = 'block';
            });
        }
        // Make functions globally available
        window.loadGltf = loadGltf;

        init();
    </script>
</body>

</html>