<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #error-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            max-width: 80%;
        }
    </style>
</head>

<body>
    <div id="error-container"></div>
    <script type="importmap">
    {
        "imports": {
            "three": "./libs/three/three.module.js",
            "three/addons/": "./libs/three/addons/",
            "lil-gui": "./libs/lil-gui/lil-gui.esm.js"
        }
    }
</script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        window.addEventListener('error', (event) => {
            const errorContainer = document.getElementById('error-container');
            let message = 'An unexpected error occurred: ' + event.message;
            if (event.error && event.error.stack) {
                message += '\n' + event.error.stack;
            }
            errorContainer.style.whiteSpace = 'pre-wrap';
            errorContainer.innerText = message;
            errorContainer.style.display = 'block';
            console.error('Unhandled error:', event.error);
        });

        let scene, camera, renderer, controls, gui;
        let modelDefaultCameraZ;
        let cameraParams;
        let mixer, clock;
        let ambientLight, directionalLight;
        let targetZoom;
        let isAnimatingZoom = false;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            modelDefaultCameraZ = controls.getDistance();
            targetZoom = modelDefaultCameraZ;

            ambientLight = new THREE.HemisphereLight(0xcccccc, 0x444444, 2);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(-5, 10, -7.5);
            scene.add(directionalLight2);

            setupGui();

            window.addEventListener('resize', onWindowResize, false);

            window.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'h') {
                    gui.open(gui._closed);
                }
                if (event.key.toLowerCase() === 'r') {
                    if (cameraParams && cameraParams.reset) {
                        cameraParams.reset();
                    }
                }
            });

            animate();
        }

        function setupGui() {
            if (gui) {
                gui.destroy();
            }
            gui = new GUI();
            gui.title('Configurations')

            const params = {
                backgroundColor: '#' + scene.background.getHexString(),
                ambientSkyColor: '#' + ambientLight.color.getHexString(),
                ambientGroundColor: '#' + ambientLight.groundColor.getHexString(),
                directionalColor: '#' + directionalLight.color.getHexString(),
            };

            const environmentFolder = gui.addFolder('Environment');
            environmentFolder.addColor(params, 'backgroundColor').name('Background').onChange((value) => {
                scene.background.set(value);
            });

            const ambientFolder = environmentFolder.addFolder('Hemisphere Light');
            ambientFolder.add(ambientLight, 'intensity', 0, 100).name('Intensity');
            ambientFolder.addColor(params, 'ambientSkyColor').name('Sky Color').onChange((value) => {
                ambientLight.color.set(value);
            });
            ambientFolder.addColor(params, 'ambientGroundColor').name('Ground Color').onChange((value) => {
                ambientLight.groundColor.set(value);
            });

            const dirLightFolder = environmentFolder.addFolder('Directional Light');
            dirLightFolder.add(directionalLight, 'intensity', 0, 100).name('Intensity');
            dirLightFolder.addColor(params, 'directionalColor').name('Color').onChange((value) => {
                directionalLight.color.set(value);
            });
            dirLightFolder.add(directionalLight.position, 'x', -100, 100).name('Position X');
            dirLightFolder.add(directionalLight.position, 'y', -100, 100).name('Position Y');
            dirLightFolder.add(directionalLight.position, 'z', -100, 100).name('Position Z');
            environmentFolder.close();

            gui.close();

            cameraParams = {
                reset: () => {
                    isAnimatingZoom = true;
                    targetZoom = modelDefaultCameraZ;
                }
            };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) {
                mixer.update(clock.getDelta());
            }

            if (isAnimatingZoom) {
                const currentDistance = controls.getDistance();
                if (Math.abs(currentDistance - targetZoom) > 0.01) {
                    const newDistance = THREE.MathUtils.lerp(currentDistance, targetZoom, 0.1);
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    if (direction.lengthSq() > 0) {
                        camera.position.copy(controls.target).addScaledVector(direction, newDistance);
                    }
                } else {
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    if (direction.lengthSq() > 0) {
                        camera.position.copy(controls.target).addScaledVector(direction, targetZoom);
                    }
                    isAnimatingZoom = false;
                }
            } else {
                if (controls.enabled) {
                    targetZoom = controls.getDistance();
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        let currentModel;

        async function loadGltf(path) {
            const loader = new GLTFLoader();
            try {
                const gltf = await loader.loadAsync(path);

                if (currentModel) {
                    scene.remove(currentModel);
                }
                if (mixer) {
                    mixer.stopAllAction();
                    mixer = null;
                    clock = null;
                }

                setupGui();

                currentModel = gltf.scene;
                const animations = gltf.animations;
                scene.add(currentModel);

                if (animations && animations.length) {
                    clock = new THREE.Clock();
                    mixer = new THREE.AnimationMixer(currentModel);
                    let activeAction = null;

                    const animationPanel = gui.addFolder('Animations');
                    animationPanel.close();

                    const animsByName = {};
                    animations.forEach((clip, i) => {
                        const name = clip.name || `Animation ${i + 1}`;
                        animsByName[name] = clip;
                    });

                    const animParams = {
                        clip: animations[0].name || 'Animation 1',
                        play: () => {
                            if (activeAction) {
                                activeAction.paused = !activeAction.paused;
                            } else {
                                playSelectedAnimation();
                            }
                        },
                        stop: () => {
                            if (mixer) {
                                mixer.stopAllAction();
                                activeAction = null;
                            }
                        },
                        time: 0,
                    };

                    function playSelectedAnimation() {
                        if (mixer) {
                            mixer.stopAllAction();
                        }
                        const clip = animsByName[animParams.clip];
                        if (clip) {
                            activeAction = mixer.clipAction(clip);
                            activeAction.reset().play();
                        }
                    }

                    animationPanel.add(animParams, 'clip', Object.keys(animsByName)).name('Animation').onChange(playSelectedAnimation);
                    animationPanel.add(animParams, 'play').name('Play/Pause');
                    animationPanel.add(animParams, 'stop').name('Stop');
                    animationPanel.add(mixer, 'timeScale', 0.1, 2).name('Speed');

                    playSelectedAnimation();
                }

                document.getElementById('error-container').style.display = 'none';

                const box = new THREE.Box3().setFromObject(currentModel);
                const center = box.getCenter(new THREE.Vector3());
                currentModel.position.sub(center); // center the model
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                // Adjust camera clipping planes to fit the model and prevent clipping
                if (maxDim > 0) {
                    camera.near = Math.max(0.01, maxDim / 100);
                    camera.far = maxDim * 100;
                    camera.updateProjectionMatrix();
                }

                const fov = camera.fov * (Math.PI / 180);
                const aspect = camera.aspect;

                const distanceToFitHeight = (size.y / 2) / Math.tan(fov / 2);
                const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspect);
                const distanceToFitWidth = (size.x / 2) / Math.tan(horizontalFov / 2);

                let cameraZ = Math.max(distanceToFitHeight, distanceToFitWidth);
                cameraZ += size.z / 2; // offset for model depth
                cameraZ *= 1.2; // add 20% margin

                const cameraY = size.y / 4; // slightly elevated camera

                camera.position.set(0, cameraY, cameraZ);
                controls.target.set(0, 0, 0);
                controls.update();
                modelDefaultCameraZ = controls.getDistance();
                targetZoom = modelDefaultCameraZ;
                isAnimatingZoom = false;

            } catch (error) {
                console.error(error);
                const errorContainer = document.getElementById('error-container');
                errorContainer.innerText = 'Error loading GLTF: ' + error.message;
                errorContainer.style.display = 'block';
            }
        }
        // Make functions globally available
        window.loadGltf = loadGltf;

        init();
    </script>
</body>

</html>