<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #error-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            max-width: 80%;
        }
    </style>
</head>

<body>
    <div id="error-container"></div>
    <script type="importmap">
    {
        "imports": {
            "three": "./libs/three/three.module.js",
            "three/addons/": "./libs/three/addons/",
            "lil-gui": "./libs/lil-gui/lil-gui.esm.js"
        }
    }
</script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';

        window.addEventListener('error', (event) => {
            const errorContainer = document.getElementById('error-container');
            let message = 'An unexpected error occurred: ' + event.message;
            if (event.error && event.error.stack) {
                message += '\n' + event.error.stack;
            }
            errorContainer.style.whiteSpace = 'pre-wrap';
            errorContainer.innerText = message;
            errorContainer.style.display = 'block';
            console.error('Unhandled error:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            const errorContainer = document.getElementById('error-container');
            let message = 'An unhandled promise rejection occurred: ';
            if (event.reason) {
                if (event.reason instanceof Error) {
                    message += event.reason.message;
                    if (event.reason.stack) {
                        message += '\n' + event.reason.stack;
                    }
                } else {
                    try {
                        message += JSON.stringify(event.reason, null, 2);
                    } catch (e) {
                        message += String(event.reason);
                    }
                }
            } else {
                message += 'No reason provided.';
            }
            errorContainer.style.whiteSpace = 'pre-wrap';
            errorContainer.innerText = message;
            errorContainer.style.display = 'block';
            console.error('Unhandled rejection:', event.reason);
        });

        let scene, camera, renderer, controls, gui;
        let modelDefaultCameraZ;
        let cameraParams;
        let mixer, clock;
        let ambientLight, directionalLight;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            modelDefaultCameraZ = controls.getDistance();

            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            setupGui();

            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function setupGui() {
            if (gui) {
                gui.destroy();
            }
            gui = new GUI();
            window.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'h') {
                    gui.domElement.style.display = gui.domElement.style.display === 'none' ? 'block' : 'none';
                }
            });

            const params = {
                backgroundColor: '#' + scene.background.getHexString(),
                ambientColor: '#' + ambientLight.color.getHexString(),
                directionalColor: '#' + directionalLight.color.getHexString(),
            };

            gui.addColor(params, 'backgroundColor').name('Background').onChange((value) => {
                scene.background.set(value);
            });

            const lightFolder = gui.addFolder('Lights');
            lightFolder.add(ambientLight, 'intensity', 0, 2).name('Ambient');
            lightFolder.addColor(params, 'ambientColor').name('Ambient Color').onChange((value) => {
                ambientLight.color.set(value);
            });

            const dirLightFolder = lightFolder.addFolder('Directional');
            dirLightFolder.add(directionalLight, 'intensity', 0, 2).name('Intensity');
            dirLightFolder.addColor(params, 'directionalColor').name('Directional Color').onChange((value) => {
                directionalLight.color.set(value);
            });
            dirLightFolder.add(directionalLight.position, 'x', -20, 20);
            dirLightFolder.add(directionalLight.position, 'y', -20, 20);
            dirLightFolder.add(directionalLight.position, 'z', -20, 20);

            const cameraFolder = gui.addFolder('Camera');
            cameraParams = {
                get zoom() {
                    return controls.getDistance();
                },
                set zoom(value) {
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    camera.position.copy(controls.target).addScaledVector(direction, value);
                    controls.update();
                },
                reset: () => {
                    const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                    camera.position.copy(controls.target).addScaledVector(direction, modelDefaultCameraZ);
                    controls.update();
                }
            };
            cameraFolder.add(cameraParams, 'zoom', 0.1, 50).name('Zoom').listen();
            cameraFolder.add(cameraParams, 'reset').name('Reset Zoom');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            controls.update();
            renderer.render(scene, camera);
        }

        let currentModel;

        function loadGltf(path) {
            const loader = new GLTFLoader();
            loader.load(path, (gltf) => {
                if (currentModel) {
                    scene.remove(currentModel);
                }
                if (mixer) {
                    mixer.stopAllAction();
                    mixer = null;
                    clock = null;
                }

                setupGui();

                currentModel = gltf.scene;
                const animations = gltf.animations;
                scene.add(currentModel);

                if (animations && animations.length) {
                    clock = new THREE.Clock();
                    mixer = new THREE.AnimationMixer(currentModel);
                    let activeAction = null;

                    const animationPanel = gui.addFolder('Animations');

                    const animsByName = {};
                    animations.forEach((clip, i) => {
                        const name = clip.name || `Animation ${i + 1}`;
                        animsByName[name] = clip;
                    });

                    const animParams = {
                        clip: animations[0].name || 'Animation 1',
                        play: () => {
                            if (activeAction) {
                                activeAction.paused = !activeAction.paused;
                            } else {
                                playSelectedAnimation();
                            }
                        },
                        stop: () => {
                            if (mixer) {
                                mixer.stopAllAction();
                                activeAction = null;
                            }
                        },
                        time: 0,
                    };

                    function playSelectedAnimation() {
                        if (mixer) {
                            mixer.stopAllAction();
                        }
                        const clip = animsByName[animParams.clip];
                        if (clip) {
                            activeAction = mixer.clipAction(clip);
                            activeAction.reset().play();
                        }
                    }

                    animationPanel.add(animParams, 'clip', Object.keys(animsByName)).name('Animation').onChange(playSelectedAnimation);
                    animationPanel.add(animParams, 'play').name('Play/Pause');
                    animationPanel.add(animParams, 'stop').name('Stop');
                    animationPanel.add(mixer, 'timeScale', 0.1, 2).name('Speed');

                    playSelectedAnimation();
                }

                document.getElementById('error-container').style.display = 'none';

                const box = new THREE.Box3().setFromObject(currentModel);
                const center = box.getCenter(new THREE.Vector3());
                currentModel.position.sub(center); // center the model
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                // Adjust camera clipping planes to fit the model and prevent clipping
                if (maxDim > 0) {
                    camera.near = Math.max(0.01, maxDim / 100);
                    camera.far = maxDim * 100;
                    camera.updateProjectionMatrix();
                }

                const fov = camera.fov * (Math.PI / 180);
                const aspect = camera.aspect;

                const distanceToFitHeight = (size.y / 2) / Math.tan(fov / 2);
                const horizontalFov = 2 * Math.atan(Math.tan(fov / 2) * aspect);
                const distanceToFitWidth = (size.x / 2) / Math.tan(horizontalFov / 2);

                let cameraZ = Math.max(distanceToFitHeight, distanceToFitWidth);
                cameraZ += size.z / 2; // offset for model depth
                cameraZ *= 1.2; // add 20% margin

                const cameraY = size.y / 4; // slightly elevated camera

                camera.position.set(0, cameraY, cameraZ);
                controls.target.set(0, 0, 0);
                controls.update();
                modelDefaultCameraZ = controls.getDistance();

            }, undefined, (error) => {
                console.error(error);
                const errorContainer = document.getElementById('error-container');
                errorContainer.innerText = 'Error loading GLTF: ' + error.message;
                errorContainer.style.display = 'block';
            });
        }
        // Make functions globally available
        window.loadGltf = loadGltf;

        init();
    </script>
</body>

</html>